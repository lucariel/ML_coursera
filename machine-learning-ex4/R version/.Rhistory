count(denom)
gss_cat6<-gss_cat%>%
filter(relig="Protestant")%>%
count(denom)
gss_cat6<-gss_cat%>%
filter(relig=="Protestant")%>%
count(denom)
gss_cat6<-gss_cat%>%
filter(relig!="Protestant")%>%
count(denom)
View(gss_cat6)
##If I filter out the protestant, denom entries are meaningless
##c(No answer,Don't know,No denomination,Not applicable)
level_prot<-c("Protestant")
gss_cat4<-gss_cat%>%
mutate(
relig_factor = factor(relig, levels = level_prot)
)
gss_cat7<-gss_cat%>%
mutate(
relig_factor = factor(relig, levels = level_prot)
)
ggplot(gss_cat7, aes(rincome_factor)) +
geom_bar()
ggplot(gss_cat7, aes(relig_factor)) +
geom_bar()
ggplot(gss_cat7, aes(denom)) +
geom_bar()
ggplot(gss_cat7, aes(denom)) +
geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))
gss_cat7<-gss_cat%>%
mutate(
relig_factor = factor(relig, levels = level_prot)
)%>%
filter(!is.na(relig_factor))
ggplot(gss_cat7, aes(denom)) +
geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))
library(tidyverse)
library(forcats)
gss_cat%>%
count(relig)
level_relig <- c("No answer", "Don't know","Inter-nondenominational", "Native american",
"Christian","Orthodox-christian","Moslem/islam","Other eastern","Hinduism",
"Buddhism","Other","None","Jewish","Catholic","Protestant"
)
gss_cat%>%
count(denom)
dnoems<-gss_cat%>%
count(denom)
View(dnoems)
level_denom<-dnoems$
##Protestant
gss_cat%>%
count(partyid)
level_denom<-dnoems$denom
level_denom
gss_cat%>%ggplot(aes(denom))+geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))
gss_cat%>%ggplot(aes(denom))+geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))+
facet_grid(relig)
gss_cat%>%ggplot(aes(denom))+geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))+
facet_grid(relig~ .)
gss_cat%>%ggplot(aes(denom))+geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))+
facet_grid(relig)
## with a visualisation you could make a facet plot
##First change de levels of relig
gss_cat7<-gss_cat%>%
mutate(
relig_factor = factor(rincome, levels = c("Protestant"))
)
gss_cat7%>%ggplot(aes(denom))+geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))+
facet_grid(relig_factor)
## with a visualisation you could make a facet plot
##First change de levels of relig
gss_cat7<-gss_cat%>%
mutate(
relig_factor = factor(rincome, levels = c("Protestant"))
)
gss_cat7%>%ggplot(aes(denom))+geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))+
facet_grid(relig_factor)
gss_cat7%>%ggplot(aes(denom))+geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))+
facet_grid(gss_cat7$relig_factor)
dnoems<-gss_cat%>%
count(relig)
dnoems
## with a visualisation you could make a facet plot
##First change de levels of relig
gss_cat7<-gss_cat%>%
mutate(
relig_factor = factor(rincome, levels = c("Protestant"))
)
gss_cat7%>%ggplot(aes(denom))+geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))+
facet_grid(relig_factor)
View(gss_cat7)
## with a visualisation you could make a facet plot
##First change de levels of relig
gss_cat7<-gss_cat%>%
mutate(
relig_factor = factor(relig, levels = c("Protestant"))
)
gss_cat6<-gss_cat%>%
filter(relig!="Protestant")%>%
count(denom)
## with a visualisation you could make a facet plot
##First change de levels of relig
gss_cat7<-gss_cat%>%
mutate(
relig_factor = factor(relig, levels = c("Protestant"))
)
View(gss_cat7)
gss_cat7%>%ggplot(aes(denom))+geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))+
facet_grid(relig_factor)
gss_cat7%>%ggplot(aes(denom))+geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))+
facet_grid(gss_cat7$relig_factor)
colnames(gss_cat7)
View(gss_cat)
source('~/Documents/R/R for Data Science/15Factors.R', echo=TRUE)
View(gss_cat)
gss_cat%>%group_by(year, partyid)%>%summarise(n = n())
gss_cat9<-gss_cat %>%
mutate(partyid = fct_collapse(partyid,
other = c("No answer", "Don't know", "Other party"),
rep = c("Strong republican", "Not str republican"),
ind = c("Ind,near rep", "Independent", "Ind,near dem"),
dem = c("Not str democrat", "Strong democrat")
)) %>%
count(partyid)
gss_cat9%>%group_by(year, partyid)%>%summarise(n = n())
gss_cat9<-gss_cat %>%
mutate(partyid = fct_collapse(partyid,
other = c("No answer", "Don't know", "Other party"),
rep = c("Strong republican", "Not str republican"),
ind = c("Ind,near rep", "Independent", "Ind,near dem"),
dem = c("Not str democrat", "Strong democrat")
))
gss_cat9%>%group_by(year, partyid)%>%summarise(n = n())
specie=c(rep("sorgho" , 3) , rep("poacee" , 3) , rep("banana" , 3) , rep("triticum" , 3) )
condition=rep(c("normal" , "stress" , "Nitrogen") , 4)
value=abs(rnorm(12 , 0 , 15))
data=data.frame(specie,condition,value)
data
gss_cat9
gss_cat9%>%
group_by(year, partyid)%>%
summarise(n = n())#%>%
gss_cat9%>%
group_by(year, partyid)%>%
summarise(n = n())%>%
ggplot(aes(fill = partyid, y = n, x = year))+
geom_bar(stat="identity", position="fill" )
count(gss_cat$rincome)
gss_cat$rincome%>%
count()
gss_cat%>%
count(rincome)
rincome_list<-gss_cat%>%
count(rincome)
rincome_list <- rincome_list$rincome
rincome_list
gss_cat10<-gss_cat %>%
mutate(partyid = fct_collapse(rincome,
no_data= c("No answer", "Don't know", "Refused"),
zero_10k= c("Lt $1000", "$1000 to 2999", "$3000 to 3999",
"$4000 to 4999","$5000 to 5999","$6000 to 6999",
"$7000 to 7999", "$8000 to 9999"),
k10_k25 = c("$10000 - 14999", "$15000 - 19999", "$20000 - 24999")
k25_more = "$25000 or more"
)) %>%
count(rincome)
gss_cat10<-gss_cat %>%
mutate(partyid = fct_collapse(rincome,
no_data= c("No answer", "Don't know", "Refused"),
zero_10k= c("Lt $1000", "$1000 to 2999", "$3000 to 3999",
"$4000 to 4999","$5000 to 5999","$6000 to 6999",
"$7000 to 7999", "$8000 to 9999"),
k10_k25 = c("$10000 - 14999", "$15000 - 19999", "$20000 - 24999"),
k25_more = "$25000 or more"
)) %>%
count(rincome)
gss_cat10
gss_cat10<-gss_cat %>%
mutate(rincome = fct_collapse(rincome,
no_data= c("No answer", "Don't know", "Refused"),
zero_10k= c("Lt $1000", "$1000 to 2999", "$3000 to 3999",
"$4000 to 4999","$5000 to 5999","$6000 to 6999",
"$7000 to 7999", "$8000 to 9999"),
k10_k25 = c("$10000 - 14999", "$15000 - 19999", "$20000 - 24999"),
k25_more = "$25000 or more"
)) %>%
count(rincome)
gss_cat10
hist(gss_cat10)
ggplot(gss_cat10, aes(rincome)) +
geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))
rincome_list
gss_cat10<-gss_cat %>%
mutate(rincome = fct_collapse(rincome,
no_data= c("No answer", "Don't know", "Refused", "Not applicable"),
zero_10k= c("Lt $1000", "$1000 to 2999", "$3000 to 3999",
"$4000 to 4999","$5000 to 5999","$6000 to 6999",
"$7000 to 7999", "$8000 to 9999"),
k10_k25 = c("$10000 - 14999", "$15000 - 19999", "$20000 - 24999"),
k25_more = "$25000 or more"
)) %>%
count(rincome)
ggplot(gss_cat10, aes(rincome)) +
geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))
gss_cat10
gss_cat10%>%ggplot(aes(x =rincome, y = n ))+geom_bar()
gss_cat10%>%ggplot(aes(x =rincome ))+geom_bar()
gss_cat10%>%ggplot(aes(x =n ))+geom_bar()
gss_cat10
##or maby all non numerical values
income_level3<-c("Lt $1000",
"$1000 to 2999","$3000 to 3999","$4000 to 4999","$5000 to 5999",
"$6000 to 6999","$7000 to 7999","$8000 to 9999","$10000 - 14999","$15000 - 19999",
"$20000 - 24999","$25000 or more")
gss_cat4<-gss_cat%>%
mutate(
rincome_factor = factor(rincome, levels = income_level3)
)%>%
filter(!is.na(rincome_factor))
ggplot(gss_cat4, aes(rincome_factor)) +
geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))
ggplot(gss_cat10, aes(rincome)) +
geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))
gss_cat10<-gss_cat %>%
mutate(rincome = fct_collapse(rincome,
no_data= c("No answer", "Don't know", "Refused", "Not applicable"),
zero_10k= c("Lt $1000", "$1000 to 2999", "$3000 to 3999",
"$4000 to 4999","$5000 to 5999","$6000 to 6999",
"$7000 to 7999", "$8000 to 9999"),
k10_k25 = c("$10000 - 14999", "$15000 - 19999", "$20000 - 24999"),
k25_more = "$25000 or more"
))
ggplot(gss_cat10, aes(rincome)) +
geom_bar()+
theme(axis.text.x = element_text(angle = 90, hjust = 1))
source('~/Documents/ML Coursera/machine-learning-ex4/R version/ex4.R', echo=TRUE)
setwd("~/Documents/ML Coursera/machine-learning-ex4/R version")
source('~/Documents/ML Coursera/machine-learning-ex4/R version/ex4.R', echo=TRUE)
library(lbfgsb3) #simil fmincg
opt <- lbfgsb3_(initial_nn_params, fn = costFunction, gr=gradFunction,
control = list(trace=1,maxit=50))
lbfgsb3_ <- function (prm, fn, gr = NULL, lower = -Inf, upper = Inf, control = list(),
...)
{
tasklist <- c("NEW_X", "START", "STOP", "FG", "ABNORMAL_TERMINATION_IN_LNSRCH",
"CONVERGENCE", "CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_<=_PGTOL",
"CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH", "ERROR: FTOL .LT. ZERO",
"ERROR: GTOL .LT. ZERO", "ERROR: INITIAL G .GE. ZERO",
"ERROR: INVALID NBD", "ERROR: N .LE. 0", "ERROR: NO FEASIBLE SOLUTION",
"ERROR: STP .GT. STPMAX", "ERROR: STP .LT. STPMIN",
"ERROR: STPMAX .LT. STPMIN", "ERROR: STPMIN .LT. ZERO",
"ERROR: XTOL .LT. ZERO", "FG_LNSRCH", "FG_START", "RESTART_FROM_LNSRCH",
"WARNING: ROUNDING ERRORS PREVENT PROGRESS", "WARNING: STP .eq. STPMAX",
"WARNING: STP .eq. STPMIN", "WARNING: XTOL TEST SATISFIED")
ctrl <- list(maxit = 100, trace = 0, iprint = 0L)
namc <- names(control)
if (!all(namc %in% names(ctrl)))
stop("unknown names in control: ", namc[!(namc %in%
names(ctrl))])
ctrl[namc] <- control
iprint <- as.integer(ctrl$iprint)
factr <- 1e+07
pgtol <- 1e-05
nmax <- 26260
mmax <- 17L
if (length(prm) > nmax)
stop("The number of parameters cannot exceed 1024")
n <- as.integer(length(prm))
m <- 5L
nbd <- rep(2L, n)
nwa <- 2 * mmax * nmax + 5 * nmax + 11 * mmax * mmax + 8 *
mmax
wa <- rep(0, nwa)
dsave <- rep(0, 29)
lsave <- rep(TRUE, 4)
isave <- rep(0L, 44)
iwa <- rep(0L, 3 * nmax)
csave <- ""
if (length(lower) == 1)
lower <- rep(lower, n)
if (length(upper) == 1)
upper <- rep(upper, n)
bigval <- .Machine$double.xmax/10
for (i in 1:n) {
if (is.finite(lower[i])) {
if (is.finite(upper[i]))
nbd[i] <- 2
else {
nbd[i] <- 1
upper[i] <- bigval
}
}
else {
if (is.finite(upper[i])) {
nbd[i] <- 3
lower[i] <- -bigval
}
else {
nbd[i] <- 0
upper[i] <- bigval
lower[i] <- -bigval
}
}
}
itask <- 2L
task <- tasklist[itask]
f <- .Machine$double.xmax/100
g <- rep(f, n)
icsave <- 0
repeat {
if (isave[34] > ctrl$maxit )
break
if (ctrl$trace >= 2) {
cat("Before call, f=", f, "  task number ", itask,
" ")
print(task)
}
possibleError <- tryCatch(
result <- .Fortran("lbfgsb3", n = as.integer(n), m = as.integer(m),
x = as.double(prm), l = as.double(lower), u = as.double(upper),
nbd = as.integer(nbd), f = as.double(f), g = as.double(g),
factr = as.double(factr), pgtol = as.double(pgtol),
wa = as.double(wa), iwa = as.integer(iwa), itask = as.integer(itask),
iprint = as.integer(iprint), icsave = as.integer(icsave),
lsave = as.logical(lsave), isave = as.integer(isave),
dsave = as.double(dsave))
, error = function(e) e)
if(inherits(possibleError, "error"))
break
itask <- result$itask
icsave <- result$icsave
prm <- result$x
g <- result$g
iwa <- result$iwa
wa <- result$wa
nbd <- result$nbd
lsave <- result$lsave
isave <- result$isave
dsave <- result$dsave
if (ctrl$trace > 2) {
cat("returned from lbfgsb3\n")
cat("returned itask is ", itask, "\n")
task <- tasklist[itask]
cat("changed task to ", task, "\n")
}
if (itask %in% c(4L, 20L, 21L)) {
if (ctrl$trace >= 2) {
cat("computing f and g at prm=")
print(prm)
}
f <- fn(prm, ...)
if (is.null(gr)) {
g <- grad(fn, prm, ...)
}
else {
g <- gr(prm, ...)
}
if (ctrl$trace > 0) {
cat("At iteration ", isave[34], " f =", f)
if (ctrl$trace > 1) {
cat("max(abs(g))=", max(abs(g)))
}
cat("\n")
}
}
else {
if (itask == 1L) {
}
else break
}
}
info <- list(task = task, itask = itask, lsave = lsave,
icsave = icsave, dsave = dsave, isave = isave)
ans <- list(prm = prm, f = f, g = g, info = info)
}
opt <- lbfgsb3_(initial_nn_params, fn = costFunction, gr=gradFunction,
control = list(trace=1,maxit=50))
labmda <- 1
opt <- lbfgsb3_(initial_nn_params, fn = costFunction, gr=gradFunction,
control = list(trace=1,maxit=50))
lambda <- 1
opt <- lbfgsb3_(initial_nn_params, fn = costFunction, gr=gradFunction,
control = list(trace=1,maxit=50))
source("lbfgsb3_") #simil fmincg
source("lbfgsb3_.R") #simil fmincg
predict <- function(Theta1, Theta2, X){
#PREDICT Predict the label of an input given a trained neural network
# p = PREDICT(Theta1, Theta2, X) outputs the predicted label of X given the
#  trained weights of a neural network (Theta1, Theta2)
# Useful values
m <- nrow(X)
num_labels <- nrow(Theta2)
# You need to return the following variables correctly
p <- rep(0, m)
h1 <- sigmoid(cbind(1, X) %*% t(Theta1))
h2 <- sigmoid(cbind(1, h1) %*% t(Theta2))
p <- apply(h2,1,which.max)
return(p)
}
pred <- predict(Theta1, Theta2, X)
# accuracy
print(mean(pred==y) * 100)
# accuracy
print(mean(pred==y))
#20.3.5 Exercises
#1.Describe the difference between is.finite(x) and !is.infinite(x).
is.finite(Inf)
!is.infinite(Inf)
#20.3.5 Exercises
#1.Describe the difference between is.finite(x) and !is.infinite(x).
is.finite(-Inf)
!is.infinite(-Inf)
#20.3.5 Exercises
#1.Describe the difference between is.finite(x) and !is.infinite(x).
is.finite(NA)
!is.infinite(NA)
dplyr::near
#3.A logical vector can take 3 possible values. How many possible values can an integer vector take? How many possible values can a double take? Use google to do some research.
##For integers vectors, R uses a 32-bit representation. This means that it can represent up to 232 different values with integers. One of these values is set aside for NA_integer_. From the help for integer
.Machine$integer.max
a = 2
a=2.3
round(a)
as.integer(a)
a=
2
floor(a)
ceiling(a)
round(a)
#4.Brainstorm at least four functions that allow you to convert a double to an integer. How do they differ? Be precise.
##There are three alternatives using round, floor and ceiling which
double_to_int1<-function(x){
x<as.integer(round(a))
}
double_to_int2<-function(x){
x<as.integer(floor(a))
}
double_to_int3<-function(x){
x<as.integer(ceiling(a))
}
double_to_int4<-function(x){
x<as.integer(trunc(a))
}
#4.Brainstorm at least four functions that allow you to convert a double to an integer. How do they differ? Be precise.
##There are three alternatives using round, floor and ceiling which
a<-34.3
double_to_int1(a)
double_to_int1<-function(x){
x<-as.integer(round(a))
}
double_to_int1(a)
double_to_int1<-function(x){
x<-as.integer(round(a))
x
}
double_to_int1(a)
a<-34.3
double_to_int2<-function(x){
x<-as.integer(floor(a))
x
}
double_to_int2(a)
a<-34.3
double_to_int3(a)
a<-34.3
double_to_int3(a)
double_to_int3<-function(x){
x<-as.integer(ceiling(a))
x
}
double_to_int3(a)
a<-34.3
double_to_int4<-function(x){
x<-as.integer(trunc(a))
}
double_to_int4(a)
double_to_int4<-function(x){
x<-as.integer(trunc(a))
x
}
double_to_int4(a)
parse_number()
#5.What functions from the readr package allow you to turn a string into logical, integer, and double vector?
##parse_logical(), parse_number()
parse_number("32422")
#5.What functions from the readr package allow you to turn a string into logical, integer, and double vector?
##parse_logical(), parse_number()
parse_number("32422.23")
#5.What functions from the readr package allow you to turn a string into logical, integer, and double vector?
##parse_logical(), parse_number()
parse_integer("32422.23")
#5.What functions from the readr package allow you to turn a string into logical, integer, and double vector?
##parse_logical(), parse_number()
parse_integer("32422")
